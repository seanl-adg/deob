var aceEditor = require('./aceeditor.js');
var throttle = require('lodash.throttle');

/**
 * Stores the state of tabs as key-value pairs.
 * key is an integer, value is an object containing information 
 * id: the id attribute of the DOM editor element that the corresponding tab contains
 * title: the displayed title of the tab.
 * needSave: bool, true -> autoSaver will update the value in localStorage.
 * pendingStorageRemoval: bool, true -> autoSaver will delete its data in localStorage, and then delete the key.
 */
var tabs = Object.create(null);

/**
 * Stores all indices assigned to tabs. It also reflects the displayed order of tabs (when tabs become draggable)
 * addNew method returns the smallest non-negative integer that hasn't been assigned to tabs.
 */
var indices = [];

indices.complement = [0];
indices.updated = true;

indices.addNew = function() {
    var newIndex = this.complement.shift();
    this.push(newIndex);
    if(this.complement.length === 0) {
        this.complement.push(indices.length);
    }
    this.updated = true;
    return newIndex;
};

indices.delete = function(index) {
    this.splice(this.indexOf(index), 1);
    this.complement.splice(sortedIndex(this.complement, index), 0, index);
    this.updated = true;
};

// Gets the smallest i such that value <= array[i], assuming that the array parameter is sorted.
// http://stackoverflow.com/a/21822316
function sortedIndex(array, value) {
    var low = 0,
        high = array.length;
    while (low < high) {
        var mid = (low + high) >>> 1;
        if (array[mid] < value) low = mid + 1;
        else high = mid;
    }
    return low;
}

/**
 * The index of the tab that has focus.
 */
var focusedIndex = null;

var tabsRoot; // = document.getElementById("Tabs");

/**
 * Dynamically adjust a width of a DOM node that contains all tabs label. 
 * To be called when a tab's width is changed, i.e. when a new tab is created, a tab is destroyed,
 * an input field at a label become visible, or an input field become invisible.
 */
var updateTabsWidth = function() {
    console.log("UPDATING TABS WIDTH");
    var width = 0;
    var li = document.getElementsByClassName("tab");
    for(var i = 0, l = li.length; i < l; i++) {
        width += li[i].offsetWidth;
    }
    document.getElementById("Tabs").lastElementChild.style.width = width + 5 + "px"; // add a little "grace"
    console.log("UPDATED WIDTH: " + width);
};

/**
 * When restoring sessions, such an event can fire rapidly, so using throttle.
 * Using trailing, otherwise the width will mismatch
 */
var updateTabsWidthOnChange = throttle(updateTabsWidth, 50, {
    trailing: true
});

/**
 * Creates a tab at the end of the currently opened tabs.
 * It is hidden by default, one has to manually focus it.
 * 
 * @param {string} title   - the title of the newly generated tab
 * @param {string} content  - the string of the content of the editor
 * 
 * @return the index of the tab, as registered in the indices object.
 */
var createTab = function(title, content) {
    var index = indices.addNew();
    title = title || 'Untitled ' + String(indices.length);

    var label = document.createElement('li');
    label.className = "tab";
    label.setAttribute("index", index);
    label.innerHTML = '<input class="txt" type="text"/><a href="#">' + title + '</a><span class="close">&#10006;</span>'; // use unicode "x" char for close button

    var newEditorDiv = document.createElement('div');
    var id = "Editor-" + index;
    newEditorDiv.id = id;
    newEditorDiv.classList.add("hidden"); // new tabs are hidden by default.

    tabsRoot.lastElementChild.appendChild(label);
    document.getElementById('MainEditors').appendChild(newEditorDiv);

    updateTabsWidthOnChange();

    var editor = aceEditor.initEditor(id);

    if(content) {
        editor.setValue(content, 0);
        
        // One have to manually call resize method when the value of an editor is changed via setValue,
        // or the visibility of the editor is changed in DOM.
        // https://groups.google.com/forum/#!topic/ace-discuss/TQHqey_NkBg
        editor.resize();
    }

    tabs[index] = {
        id: id,
        title: title,
        needSave: true, // Even if the tab is generated by createTab(), its index may have been changed.
        pendingStorageRemoval: false
    };

    aceEditor.getEditor(id).getSession().on("change", function() {
        tabs[index].needSave = true;
        saveChange();
    });

    return index;
};

/**
 * Focuses a tab having an index
 */
var focusTab = function(newIndex) {
    if(focusedIndex !== null) {
        document.querySelector('.tab[index="' + focusedIndex + '"]').classList.remove("focused");
        document.getElementById("Editor-" + focusedIndex).classList.add("hidden");
    }

    if(newIndex !== undefined) {
        focusedIndex = newIndex;
        tabsRoot.querySelector('.tab[index="' + focusedIndex + '"]').classList.add("focused");
        document.getElementById("Editor-" + focusedIndex).classList.remove("hidden");
        aceEditor.getEditor(tabs[newIndex].id).resize();
    }
    else { 
        focusedIndex = null;
    }
    saveChange();
};

/**
 * Initializing, attaches event listeners to DOM nodes.
 */
var initTabs = function() {
    tabsRoot = document.getElementById("Tabs");
    tabsRoot.addEventListener('click', function(evt) {
        switch(evt.target.tagName.toLowerCase()) {
            case "a":
                // Clicked on a tab's label -> focus the tab.
                evt.preventDefault();
                var newIndex = Number(evt.target.parentNode.getAttribute("index"));
                if(newIndex != focusedIndex) {
                    focusTab(newIndex);
                }
                break;
            case "span":
                // Clicked on a close button -> destroy the tab.
                var index = Number(evt.target.parentNode.getAttribute("index"));
                if(focusedIndex == index) {
                    var order = indices.indexOf(index);

                    // Some logic on which tab to focus when a current focused tab is destroyed.
                    // This depends on actual tabs' order, invoking indexOf each time feels bad.
                    // Maybe should have used a different data structure.
                    if(order < indices.length - 1) {
                        focusTab(indices[order + 1]);
                    }
                    else {
                        focusTab(indices[order - 1]);
                    }
                }

                destroyTab(index);
        }
    });

    tabsRoot.addEventListener('dblclick', function(evt) {
        if(evt.target.tagName.toLowerCase() == "a") {
            // Double-clicked on a label -> show an input field to change the title.
            evt.preventDefault();
            var anchor = evt.target;
            anchor.classList.add("hidden");
            anchor.previousSibling.classList.add("shown");
            updateTabsWidthOnChange();
        }
    });

    tabsRoot.addEventListener('keydown', function(evt) {
        if(evt.target.tagName.toLowerCase() == "input") {
            switch(evt.keyCode) {
                case 37:
                case 38:
                case 39:
                case 40:
                    evt.stopPropagation();
                    break;
                case 13:
                    updateTitle(evt.target);
                    break;
            }
        }
    });

    tabsRoot.addEventListener('blur', function(evt) {
        console.log('blur EVENT');
        console.log(evt);
        if(evt.target.tagName.toLowerCase() == "input") {
            updateTitle(evt.target);
        }
    });

    document.getElementById("NewTabBtn").addEventListener("click", function() {
        focusTab(createTab());
        saveChange();
    });
};

/**
 * Update the title string of a tab as a value of an input node.
 * @param {HTMLInputNode}
 */
var updateTitle = function(inputNode) {
    var anchor = inputNode.nextSibling;
    var newTitle = inputNode.value;

    if(newTitle) {
        anchor.innerText = inputNode.value;
        var index = Number(inputNode.parentNode.getAttribute("index"));

        tabs[index].title = newTitle;
        tabs[index].needSave = true;
        saveChange();
    }

    inputNode.classList.remove("shown");
    anchor.classList.remove("hidden");
    updateTabsWidthOnChange();
};

var removeEl = function(el) {
    el.parentNode.removeChild(el);
};

/**
 * Removes a tab by its index - 
 * destroys the ace editor instance in it, and remove remaining node in DOM.
 */
var destroyTab = function(index) {
    aceEditor.destroyEditor("Editor-" + index);
    removeEl(document.getElementById("Editor-" + index));
    removeEl(document.querySelector('.tab[index="' + index + '"]'));
    updateTabsWidthOnChange();
    tabs[index].pendingStorageRemoval = true;
    indices.delete(index);
    saveChange();
};

var getEditorByIndex = function(index) {
    return aceEditor.getEditor("Editor-" + index);
};

var getCurrentEditor = function() {
    return getEditorByIndex(focusedIndex);
};

/**
 * resizes the current editor. Will be called when the size of the placeholder of tabs is changed.
 */
var resizeTabs = function() {
    if(focusedIndex != null) {
        var current = getCurrentEditor();
        current.getSession().getUseWrapMode() && current.resize();
    }
};

/**
 * Store data to localStorage.
 * Re-write only when something is changed.
 * Deletes a corresponding data when a tab is destroyed.
 */
var autoSaver = function() {
    var x;
    for(var index in tabs) {
        x = tabs[index];
        if(x.needSave) {
            window.localStorage.setItem("tab-" + index, JSON.stringify([x.title, aceEditor.getEditor(x.id).getValue()]));
            x.needSave = false;
        }
        if(x.pendingStorageRemoval) {
            window.localStorage.removeItem("tab-" + index);
            delete tabs[index];
        }
    }
    if(indices.updated) {
        window.localStorage.setItem("tabs", JSON.stringify(indices));
        indices.updated = false;
    }

    window.localStorage.setItem("focused", JSON.stringify(indices.indexOf(focusedIndex)));
};

/**
 * Throttles autoSaver.
 */
var saveChange = throttle(autoSaver, 100);

/**
 * Called at a startup of the document, reads data from localStorage and generates corresponding tabs.
 */
var restorePrevSession = function() {
    var t_indices = JSON.parse(window.localStorage.getItem("tabs"));
    var t_focused = JSON.parse(window.localStorage.getItem("focused"));
    
    // should add more robust validation here
    if(t_indices === null || t_focused === null) {
        return false;
    }

    if(t_focused == -1) {
        return true;
    }

    var i = 0, l = t_indices.length, t_index, x;
    for(; i < t_focused; i++) {
        t_index = t_indices[i];
        x = JSON.parse(window.localStorage.getItem("tab-" + t_index));
        createTab(x[0], x[1]);
    }

    t_index = t_indices[t_focused];
    x = JSON.parse(window.localStorage.getItem("tab-" + t_index));
    var t_focusedIndex = createTab(x[0], x[1]);

    for(i++; i < l; i++) {
        t_index = t_indices[i];
        x = JSON.parse(window.localStorage.getItem("tab-" + t_index));
        createTab(x[0], x[1]);
    }

    window.localStorage.clear(); // Unless new data will be corrupted by the prev data.
    focusTab(t_focusedIndex);
    return true;
};

module.exports = {
    initTabs: initTabs,
    createTab: createTab,
    getCurrentEditor: getCurrentEditor,
    resizeTabs: resizeTabs,
    restorePrevSession: restorePrevSession
};